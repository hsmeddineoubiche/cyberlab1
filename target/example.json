{"noir_version":"0.36.0+801c71880ecf8386a26737a5d8bb5b4cb164b2ab","hash":6182749630387978070,"abi":{"parameters":[{"name":"sig_limbs","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"},{"name":"mod_limbs","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"},{"name":"redc_limbs","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/8XYj1tMaRQH8Leayc4mdrN27Vp2xtq1axeTmIpo9IOISBERpR+kmKSISBERERERyV/qfTlXt+PU06Hj3Oc5z5mZvr1zP+8zTfeeJPPxmLT1Dh4HoSeZzw/vtTj06NcdmRnzt1Y02XeeMejZ3kmnQI/BG/pfy4bXviV8iZGB50DPxfAcAp6rAP/JyMC3QN+K4VsI+FYF+FIjA8+Dvg3D8wj4NgX4z0YGvh16PoZvJ+D5CvBfjAzcW3MHhscJ+A4F+DIjAy+AXojhBQS8UAH+q5GBF0EvxvAiAl6sAP/NyMB3Qt+F4TsJ+C4F+HIjAy+BvhvDSwj4bgX470YGvgd6KYbvIeClCvAVRga+F/o+DN9LwPcpwFcaGXgZ9P0YXkbA9yvA/zAy8APQyzH8AAEvV4CHjQz8IPQKDD9IwCsU4BEjA6+EfgjDKwn4IQX4KiMDPwy9CsMPE/AqBfifRgZ+BPpRDD9CwI8qwKUmMNXQj2F4NQE/pgCXmsAch16D4ccJeI0CXGoCcwL6SQw/QcBPKsClJjC10OswvJaA1ynApSYwp6DXY/gpAl6vAJeawDRAb8TwBgLeqACXmsA0QT+N4U0E/LQCXGoCcwZ6M4afIeDNCnCpCcxZ6C0YfpaAtyjApSYwrdDPYXgrAT+nAJeawJyHnsDw8wQ8oQCXmsC0Qb+A4W0E/IICXGoC0w79Ioa3E/CLCnCpCUwH9E4M7yDgnQrwsJGBX4J+GcMvEfDLCvCIkYF3Qb+C4V0E/IoCXGoCcxV6N4ZfJeDdCnCpCcw16Ncx/BoBv64Al5rA9EC/geE9BPyGAlxqAtMLvQ/Dewl4nwJcagJzE/otDL9JwG8pwKUmMP3Qb2N4PwG/rQCXmsDcgT6A4XcI+IACXGoCcxf6PQy/S8DvKcClJjCD0O9j+CABv68Al5rAPIA+hOEPCPiQAlxqAvMQ+iMMf0jAHynApSYww9AfY/gwAX+sAJeawDyBPoLhTwj4iAJcagLzFPozDH9KwJ8pwKUmMKPQn2P4KAF/rgCXmsC8gD6G4S8I+JgCPGxk4C+hv8LwlwT8lQI8YmTg49BfY/g4AX+tAJeawLyBPoHhbwj4hAJcagLzFvokhr8l4JO+1wLwizGEToZ8ADYo1dYCW9/ZCtn63laarYW20m0tsrXY1g+2frTlJi5u+ODuw90tqbs7czcq7prdXb66Kzl3UeP+v7t/de5b330Bhm25Pwv3CXGbtdrWX7b+trXG1j+2/rW11tZ/tv63tc7Welsb3KbayrS10VaWrU22NpvPj5jP6h1h3+NF0Cs66upbwh2JRLihsbHN28W5p1NZ6RArvZCVXsxKZ7DSS1npZaz0clZ6JSsdYaVXs9JrWOm1rPQ6VjrKSmex0jFWOpeVzmOl81npAla6mJUuYaVLWekyVrqcla5kpatY6WpWuoaVrmWl61npJla6mZVuZaUTrHQ7K93JSnex0t2sdA8r3cdK97PSA6z0ICs9xEoPs9IjrPQoKz3GSo+z0hNzTn+6aFsF3bts8q6Ivcu0ODyPft2RGfKtO9/r50Q3xUJm+jHP558VMlMX9VL7460psH50AaxT2Du1Pra4Ix2eJ/n20vsdd+OS5su5o8i3XhL6WTHxXkt8v+O95tZdAY9TiH3wf2YCvgx1/jOtkYzWCJnpN2/e4zg8jzKPTPTcO++g75wCxHkFkNO72Un25YOz5LELr586hz0xs6yP/16Nb+/8n5G4mZ99w++VMsN5zfQzvLcphv4MmVn2BWfTide9vUs3M38W08zU92qgd/rP4+bL9st/ZOd8/Jx9cMD6QTP9b8Gg9w+ifASeZxj6cIb3C5x0ZX9FAAA=","debug_symbols":"1d3daiJBEIbhe5ljD7qq+tdbWZagiQmCaFCzsIj3vuNm1RANYVXwraOkY5d+SHy+MGbGTfc0Gb+9PEznz4tVN/yx6WaLx9F6upj3q00X/v5o9Tqa71ar9Wi57oYqOugm86f+u9S2g+55Opt0Q1HdDk72ipT2b7NokONukXO7S4v73VU/3HfI25+DTlBpFJXGUGkiKk1CpcmoNAWVpqLSNJZ+MIxZGguLY2F5LCyQhSWysEgWlsnCQllYKitLZYX9jcxSWVkqK0tlZamsLJWVpbKyVFaWysZS2VgqG+zQBUtlY6lsLJWNpbKxVDaWysZSObJUjiyVI0vlCDuizFI5slSOLJUjS+XIUjmyVE4slRNL5cRSObFUTterrCaHOMmujJNYcTIrTmHFqaw4DRUnB1YcYcVRVhxjxWGpnFkqZ5bKmaVyZqmcWSoXlsqFpXJhqVxYKheWyoWlcmGpXFgqF5bKhaVyZalcWSpXlsqVpXJlqVxZKleWypWlcmWpXFkqN5bKjaVyY6ncWCo3lsqNpXJjqdxYKjeWyo2lsgQWyxJYLktgwSyBJbMEFs0SWDb3X2B5WDpLuAHP1faPYBK+y9Na3t91kHpt+uY5/Q1OIbxnenGdXl2nN9fpo+v0yXX67Dp9cZ3eddeK665V112rrrtWXXetuu7aG5zUes/0rrtWXXetuu5add216rprzXXXmuuuNddda6679ganKt8zveuuNddda6671lx3rbnu2ui6a6Prro2uuza67tobnIB+z/Suuza67troumuj666Nrrs2ue7a5Lprk+uuTa679haXFbhjetddm1x3bXLdtcl11ybXXZtdd23227X9aryczmbTl4fPnz2y+eKy7iL5kFWKfHj08H6E5ZKheMlQOj9U635I5XQoXzJULhmqlwydfRn370qnw1Asn4fO/7dDPxSOQ/VkSM4P6fECRadP+fn39r8bsi+Gjk9EaSdD8ZKh9N9D2375a7Scjsazye43f3fr2/xx/0Lol+vfr++39Jv/AA==","file_map":{"106":{"source":"use crate::utils::msb::get_msb64;\nuse crate::utils::split_bits;\n\n/**\n * @brief U60Repr represents a BigNum element as a sequence of 60-bit unsigned integers.\n *\n * @description: used in unconstrained functions when computing witness values.\n * It is helpful to use u60 types when evaluating addition operations that can overflow the field modulus,\n * as well as when performing bit shifts.\n */\npub struct U60Repr<let N: u32, let NumSegments: u32> {\n    pub(crate) limbs: [u64; N * NumSegments],\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Add for U60Repr<N, NumSegments> {\n    fn add(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut carry: u64 = 0;\n        for i in 0..N * NumSegments {\n            let mut add: u64 = self.limbs[i] + b.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            result.limbs[i] = add;\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Sub for U60Repr<N, NumSegments> {\n    fn sub(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut borrow: u64 = 0;\n        let mut borrow_in: u64 = 0;\n\n        for i in 0..N * NumSegments {\n            borrow = ((b.limbs[i] + borrow_in) > self.limbs[i]) as u64;\n            let sub = (borrow << 60) + self.limbs[i] - b.limbs[i] - borrow_in;\n            result.limbs[i] = sub;\n            borrow_in = borrow;\n        }\n\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::convert::From<[Field; N]> for U60Repr<N, NumSegments> {\n    fn from(input: [Field; N]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N) {\n            let (lo, hi) = unsafe { split_bits::split_60_bits(input[i]) };\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::convert::Into<[Field; N]> for U60Repr<N, NumSegments> {\n    fn into(x: U60Repr<N, NumSegments>) -> [Field; N] {\n        let mut result: [Field; N] = [0; N];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..N {\n            result[i] = x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::cmp::Eq for U60Repr<N, NumSegments> {\n    fn eq(self, other: Self) -> bool {\n        self.limbs == other.limbs\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> U60Repr<N, NumSegments> {\n\n    pub(crate) unconstrained fn new<let NumFieldSegments: u32>(\n        x: [Field; N * NumFieldSegments],\n    ) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N * NumFieldSegments) {\n            let (lo, hi) = split_bits::split_60_bits(x[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn one() -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub(crate) unconstrained fn into_field_array(\n        x: U60Repr<N, NumSegments>,\n    ) -> [Field; N * NumSegments / 2] {\n        let mut result: [Field; N * NumSegments / 2] = [0; N * NumSegments / 2];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..(N * NumSegments / 2) {\n            result[i] = x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn gte(self, b: Self) -> bool {\n        let mut result = false;\n        let mut early_exit = false;\n        for i in 0..(N * NumSegments) {\n            if (b.limbs[(N * NumSegments) - 1 - i] < self.limbs[((N * NumSegments) - 1 - i)]) {\n                result = true;\n                early_exit = true;\n                break;\n            } else if (\n                b.limbs[(N * NumSegments) - 1 - i] != self.limbs[((N * NumSegments) - 1 - i)]\n            ) {\n                result = false;\n                early_exit = true;\n                break;\n            }\n        }\n        if (early_exit == false) {\n            result = (self.limbs[0] == b.limbs[0]);\n        }\n        result\n    }\n\n    pub(crate) fn get_bit(self, bit: u32) -> bool {\n        let segment_index = bit / 60;\n        let uint_index = bit % 60;\n\n        let limb: u64 = self.limbs[segment_index];\n        let value = (limb >> uint_index as u8) & 1;\n        value == 1\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = shift % 60;\n        let remainder_shift = 60 - limb_shift;\n        let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        result.limbs[0] = (self.limbs[0 + num_shifted_limbs] >> limb_shift as u8);\n\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i + num_shifted_limbs];\n            result.limbs[i] = (value >> limb_shift as u8);\n            let remainder: u64 = (value << remainder_shift as u8) & mask;\n            result.limbs[i - 1] = result.limbs[i - 1] + remainder;\n        }\n        result\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr1(&mut self) {\n        let value = self.limbs[NumSegments * N - 1];\n        self.limbs[NumSegments * N - 1] = value >> 1;\n\n        let mut remainder = (value & 1) << 59;\n\n        for i in 0..N * NumSegments {\n            let value = self.limbs[N * NumSegments - 1 - i];\n            self.limbs[N * NumSegments - 1 - i] = (value >> 1) + remainder;\n            remainder = (value << 59) & 0x800000000000000;\n        }\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shl(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; NumSegments * N] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift: u8 = 60 - limb_shift as u8;\n\n        // 83\n        // limb shift = 1\n        // inside shift = 19 bits to the left\n        // meaning we have 19 carry bits and 41 remainder bits\n        let mask: u64 = (1 as u64 << 60) - 1;\n        //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        let value = self.limbs[0];\n\n        let mut remainder = (value >> remainder_shift);\n        result.limbs[num_shifted_limbs] = (value << (limb_shift as u8)) & mask;\n\n        // shift 84. num shifted = 1\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i];\n            let upshift = ((value << (limb_shift as u8)) + remainder) & mask;\n            result.limbs[i + num_shifted_limbs] = upshift;\n            remainder = (value >> remainder_shift);\n            // let remainder: u64 = (self.limbs.get(i + num_shifted_limbs as u64) << remainder_shift as u8) & mask;\n            // result.limbs.set(i - 1, result.limbs.get(i - 1) + remainder);\n        }\n        result\n    }\n\n    pub(crate) fn increment(&mut self) {\n        let mut carry: u64 = 0;\n\n        let mut add: u64 = self.limbs[0] + 1;\n        carry = add >> 60;\n        add = add - (carry << 60);\n        self.limbs[0] = add;\n\n        for i in 1..NumSegments * N {\n            let mut add: u64 = self.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            self.limbs[i] = add;\n        }\n    }\n\n    pub(crate) unconstrained fn get_msb(val: Self) -> u32 {\n        let mut count = 0;\n        for i in 0..N * NumSegments {\n            let v = val.limbs[((N * NumSegments) - 1 - i)];\n            if (v > 0) {\n                count = 60 * ((N * NumSegments) - 1 - i) + get_msb64(v);\n                break;\n            }\n        }\n        count\n    }\n}\n","path":"/home/elho/nargo/github.com/noir-lang/noir-bignumv0.4.2/src/utils/u60_representation.nr"},"110":{"source":"global TWO_POW_56: u64 = 0x100000000000000;\nglobal TWO_POW_60: u64 = 0x1000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 120 bit fields\npub unconstrained fn split_120_bits(mut x: Field) -> (Field, Field) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_56 = ((x as u64) % TWO_POW_56) as Field;\n\n    let low = low_lower_64 + TWO_POW_64 * low_upper_56;\n    let high = (x - low_upper_56) / TWO_POW_56 as Field;\n\n    (low, high)\n}\n\n/**\n * @brief Decomposes a single field into two 60 bit fields\n *\n * @description Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\n **/\npub unconstrained fn split_60_bits(x: Field) -> (u64, u64) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let x_lower_64 = (x as u64);\n    let low = x_lower_64 % TWO_POW_60;\n    let high = ((x - (low as Field)) / TWO_POW_60 as Field) as u64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [Field; N] {\n    let mut normalized: [Field; N] = [0; N];\n    let mut inp: _ = input;\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(inp[i]);\n\n        normalized[i] = lo;\n        inp[i + 1] += hi;\n    }\n    {\n        let (lo, hi) = split_120_bits(inp[range - 1]);\n        normalized[range - 1] = lo;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/home/elho/nargo/github.com/noir-lang/noir-bignumv0.4.2/src/utils/split_bits.nr"},"111":{"source":"use crate::utils::u60_representation::U60Repr;\n\npub struct BigNumParams<let N: u32, let MOD_BITS: u32> {\n    pub has_multiplicative_inverse: bool,\n\n    // @brief modulus: all BigNum operations are evaluated modulo this value\n    pub modulus: [Field; N],\n\n    // @brief modulus but represented in a U60Repr form\n    pub modulus_u60: U60Repr<N, 2>,\n    pub modulus_u60_x4: U60Repr<N, 4>,\n\n    // @brief double_modulus: used when performing negations and subtractions\n    pub double_modulus: [Field; N],\n\n    // @brief redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n    pub redc_param: [Field; N],\n}\n\n// To be implemented by the user for any BigNum they define, or within the predefined BigNums in the `fields/` dir.\npub trait BigNumParamsGetter<let N: u32, let MOD_BITS: u32> {\n    pub fn get_params() -> BigNumParams<N, MOD_BITS>;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> BigNumParams<N, MOD_BITS> {\n    pub fn new(\n        has_multiplicative_inverse: bool,\n        modulus: [Field; N],\n        redc_param: [Field; N],\n    ) -> Self {\n        Self {\n            has_multiplicative_inverse,\n            modulus,\n            modulus_u60: U60Repr::from(modulus),\n            modulus_u60_x4: U60Repr::from(modulus),\n            double_modulus: get_double_modulus(modulus),\n            redc_param,\n        }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for BigNumParams<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        (self.has_multiplicative_inverse == other.has_multiplicative_inverse)\n            & (self.modulus == other.modulus)\n            & (self.modulus_u60 == other.modulus_u60)\n            & (self.modulus_u60_x4 == other.modulus_u60_x4)\n            & (self.double_modulus == other.double_modulus)\n            & (self.redc_param == other.redc_param)\n    }\n}\n\nfn get_double_modulus<let N: u32>(modulus: [Field; N]) -> [Field; N] {\n    let TWO_POW_120: Field = 0x1000000000000000000000000000000;\n    let m: U60Repr<N, 2> = U60Repr::from(modulus);\n    let mut result: [Field; N] = U60Repr::into(m + m);\n\n    result[0] += TWO_POW_120;\n    for i in 1..N - 1 {\n        result[i] += (TWO_POW_120 - 1);\n    }\n    result[N - 1] -= 1;\n    result\n}\n","path":"/home/elho/nargo/github.com/noir-lang/noir-bignumv0.4.2/src/params.nr"},"122":{"source":"use dep::bignum::{params::BigNumParams, RuntimeBigNum};\n\nfn main(\n    sig_limbs: [Field; 18],\n    mod_limbs: [Field; 18],\n    redc_limbs: [Field; 18]\n) {\n    // Just create the params and bignum\n    let params = BigNumParams::new(false, mod_limbs, redc_limbs);\n    let _signature = RuntimeBigNum::from_array(params, sig_limbs);\n}\n\n#[test]\nfn test_basic() {\n    let sig_limbs = [1; 18];\n    let mod_limbs = [1; 18];\n    let redc_limbs = [1; 18];\n    \n    main(sig_limbs, mod_limbs, redc_limbs);\n}\n","path":"/home/elho/Desktop/noir/cyberlab/example/src/main.nr"}},"names":["main"],"brillig_names":["split_60_bits"]}